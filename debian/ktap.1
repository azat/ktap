.TH OPEN "1" "June 2015" "open file (null) failed" "User Commands"
.SH NAME
open \- manual page for open file (null) failed
.SH SYNOPSIS
.B ktap
[\fI\,options\/\fR] \fI\,file \/\fR[\fI\,script args\/\fR] \fI\,-- cmd \/\fR[\fI\,args\/\fR]
.br
.B ktap
[\fI\,options\/\fR] \fI\,-e one-liner  -- cmd \/\fR[\fI\,args\/\fR]
.SH DESCRIPTION
.SS "Options and arguments:"
.TP
\fB\-o\fR file
: send script output to file, instead of stderr
.TP
\fB\-p\fR pid
: specific tracing pid
.TP
\fB\-C\fR cpu
: cpu to monitor in system\-wide
.TP
\fB\-T\fR
: show timestamp for event
.TP
\fB\-V\fR
: show version
.TP
\fB\-v\fR
: enable verbose mode
.TP
\fB\-q\fR
: suppress start tracing message
.TP
\fB\-d\fR
: dry run mode(register NULL callback to perf events)
.TP
\fB\-s\fR
: simple event tracing
.TP
\fB\-b\fR
: list byte codes
.TP
\fB\-le\fR [glob]
: list pre\-defined events in system
.TP
\fB\-lf\fR DSO
: list available functions from DSO
.TP
\fB\-lm\fR DSO
: list available sdt notes from DSO
.TP
file
: program read from script file
.TP
\fB\-\-\fR cmd [args]
: workload to tracing

.SH Introduction
.PP
ktap is a new script\-based dynamic tracing tool for Linux

\[la]http://www.ktap.org\[ra]

.PP
ktap is a new script\-based dynamic tracing tool for Linux.
It uses a scripting language and lets the user trace the Linux kernel dynamically.
ktap is designed to give operational insights with interoperability
that allows users to tune, troubleshoot and extend kernel and application.
It's similar to Linux SystemTap and Solaris DTrace.

.PP
ktap has different design principles from Linux mainstream dynamic tracing
language in that it's based on bytecode, so it doesn't depend upon GCC,
doesn't require compiling a kernel module for each script, safe to use in
production environment, fulfilling the embedded ecosystem's tracing needs.

.PP
Highlights features:
.IP \n+[step]

\item a simple but powerful scripting language
\item register\-based interpreter (heavily optimized) in Linux kernel
\item small and lightweight
\item not depend on the GCC toolchain for each script run
\item easy to use in embedded environments without debugging info
\item support for tracepoint, kprobe, uprobe, function trace, timer, and more
\item supported in x86, ARM, PowerPC, MIPS
\item safety in sandbox

.SH Getting started
.PP
Requirements
.IP \n+[step]

\item Linux 3.1 or later (patches are required for earlier versions)
\item \fB\fCCONFIG\_EVENT\_TRACING\fR enabled
\item \fB\fCCONFIG\_PERF\_EVENTS\fR enabled
\item 
.PP
\fB\fCCONFIG\_DEBUG\_FS\fR enabled
.PP
make sure debugfs mounted before \fB\fCinsmod ktapvm\fR

.PP
mount debugfs: \fB\fCmount \-t debugfs none /sys/kernel/debug/\fR
\item 
.PP
libelf (optional)
 Install elfutils\-libelf\-devel on RHEL\-based distros, or libelf\-dev on
 Debian\-based distros.
 Use \fB\fCmake NO\_LIBELF=1\fR to build without libelf support.
 libelf is required for resolving symbols to addresses in DSO, and for SDT.
.PP
Note that those configurations should always be enabled in Linux distribution,
like RHEL, Fedora, Ubuntu, etc.
.IP \(bu 2

\item 
.PP
Clone ktap from GitHub
.PP
.RS

.nf
$ git clone http://github.com/ktap/ktap.git

.fi
.RE
\item 
.PP
Compile ktap
.PP
.RS

.nf
$ cd ktap
$ make       #generate ktapvm kernel module and ktap binary

.fi
.RE
\item 
.PP
Load ktapvm kernel module(make sure debugfs mounted)
.PP
.RS

.nf
$ make load  #need to be root or have sudo access

.fi
.RE
\item 
.PP
Run ktap
.PP
.RS

.nf
$ ./ktap samples/helloworld.kp

.fi
.RE

.SH Language basics
.SH Syntax basics
.PP
ktap's syntax is designed with the C language syntax in mind. This is for lowering the entry barrier for C programmers who are working on the kernel or other systems software.
.IP \n+[step]

\item 
.PP
Variable declarations
.PP
The biggest syntax differences with C is that ktap is a dynamically\-typed
language, so you won't need add any variable type declaration, just
use the variable.
\item 
.PP
Functions
.PP
All functions in ktap should use keyword "function" declaration
\item 
.PP
Comments
.PP
Comments in ktap start with \fB\fC#\fR. Long comments are not supported right now.
\item 
.PP
Others
.PP
Semicolons (\fB\fC;\fR) are not required at the end of statements in ktap. ktap uses a free\-syntax style, so you are free to use ';' or not.
.PP
ktap uses \fB\fCnil\fR as \fB\fCNULL\fR. The result of an arithmetic operation on \fB\fCnil\fR is also \fB\fCnil\fR.

.PP
ktap does not have array structures, and it does not have any pointer operations.

.SH Control structures
.PP
ktap's \fB\fCif\fR/\fB\fCelse\fR statement is the same as the C language's.

.PP
There are three kinds of for\-loop in ktap:
.IP \(bu 2

\item 
.PP
a kinda Lua\-ish style:
.PP
for (i = init, limit, step) \{ body \}
\item 
.PP
the same form as in C:
.PP
for (i = init; i < limit; i += step) \{ body \}
\item 
.PP
Lua's table iterating style:
.PP
for (k, v in pairs(t)) \{ body \} # looping all elements of table
.PP
Note that ktap does not have the \fB\fCcontinue\fR keyword, but C does.

.SH Data structures
.PP
Associative arrays are heavily used in ktap; they are also called "tables".

.PP
Table declarations:

.PP
.RS

.nf
t = \{\}

.fi
.RE

.PP
How to use tables:

.PP
.RS

.nf
t[1] = 1
t[1] = "xxx"
t["key"] = 10
t["key"] = "value"

for (k, v in pairs(t)) \{ body \}   # looping all elements of table

.fi
.RE


.SH Built\-in functions and libraries
.SH Built\-in functions
.PP
\fBprint (...)\fP

.PP
Receives any number of arguments, and prints their values.
print is not intended for formatted output, but only as a
quick way to show values, typically for debugging.

.PP
For formatted output, use \fB\fCprintf\fR instead.

.PP
\fBprintf (fmt, ...)\fP

.PP
Similar to C's \fB\fCprintf\fR, for formatted string output.

.PP
\fBpairs (t)\fP

.PP
Returns three values: the next function, the table t, and nil,
so that the construction

.PP
.RS

.nf
for (k, v in pairs(t)) \{ body \}

.fi
.RE

.PP
will iterate through all the key\-value pairs in the table \fB\fCt\fR.

.PP
\fBlen (t) /len (s)\fP

.PP
If the argument is a string, returns the length of the string.

.PP
If the argument is a table, returns the number of table pairs.

.PP
\fBin\_interrupt ()\fP

.PP
Checks if it is in the context of interrupts.

.PP
\fBexit ()\fP

.PP
quits ktap programs, similar to the \fB\fCexit\fR syscall.

.PP
\fBarch ()\fP

.PP
returns machine architecture, like \fB\fCx86\fR, \fB\fCarm\fR, and etc.

.PP
\fBkernel\_v ()\fP

.PP
returns Linux kernel version string, like \fB\fC3.9\fR and etc.

.PP
\fBuser\_string (addr)\fP

.PP
accepts a userspace address, reads the string data from userspace, and returns the ktap string value.

.PP
\fBprint\_hist (t)\fP

.PP
accepts a table and outputs the table histogram to the user.

.SH Libraries
.SS Kdebug Library
.PP
\fBkdebug.trace\_by\_id (eventdef\_info, eventfun)\fP

.PP
This function is the underlying interface for the higher level tracing primitives.

.PP
Note that the \fB\fCeventdef\_info\fR argument is just a C pointer value pointing to a userspace memory block holding the real
\fB\fCeventdef\_info\fR structure. The structure definition is as follows:

.PP
.RS

.nf
struct ktap\_eventdesc \{
int nr; /* the number to id */
int *id\_arr; /* id array */
char *filter;
\};

.fi
.RE

.PP
Those \fB\fCid\fRs are read from \fB\fC/sys/kernel/debug/tracing/events/$SYS/$EVENT/id\fR.

.PP
The second argument in above example is a ktap function object:

.PP
.RS

.nf
function eventfun () \{ action \}

.fi
.RE

.PP
\fBkdebug.trace\_end (endfunc)\fP

.PP
This function is used for invoking a function when tracing ends, it will wait
until the user presses \fB\fCCTRL\-C\fR to stop tracing, then ktap will call the argument, the \fB\fCendfunc\fR function. The
user could output tracing results in that function, or do other things.

.PP
User usually do not need to use the \fB\fCkdebug\fR library directly and just use the \fB\fCtrace\fR/\fB\fCtrace\_end\fR keywords provided by the language.

.SS Timer Library
.SS Table Library
.PP
\fBtable.new (narr, nrec)\fP

.PP
pre\-allocates a table with \fB\fCnarr\fR array entries and \fB\fCnrec\fR records.


.SH Linux tracing basics
.PP
tracepoints, probe, timer, filters, ring buffer


.SH Tracing semantics in ktap
.SH Tracing block
.PP
\fBtrace EVENTDEF /FILTER/ \{ ACTION \}\fP

.PP
This is the basic tracing block in ktap. You need to use a specific \fB\fCEVENTDEF\fR string, and your own event function.

.PP
There are four types of \fB\fCEVENTDEF\fR: tracepoints, kprobes, uprobes, SDT probes.
.IP \n+[step]

\item 
.PP
tracepoint:
.PP
EventDef               Description

.ti 0
\l'\n(.lu'

.PP
syscalls:*             trace all syscalls events
syscalls:sys\fIenter\fP*   trace all syscalls entry events
kmem:*                 trace all kmem related events
sched:*                trace all sched related events
sched:sched\_switch     trace sched\_switch tracepoint
*:*                  trace all tracepoints in system

.PP
All tracepoint events are based on

.PP
.RS

.nf
/sys/kernel/debug/tracing/events/$SYS/$EVENT

.fi
.RE
\item 
.PP
ftrace (kernel 3.3+, and must be compiled with \fB\fCCONFIG\_FUNCTION\_TRACER\fR)
.PP
EventDef               Description

.ti 0
\l'\n(.lu'

.PP
ftrace:function        trace kernel functions based on ftrace

.PP
User need to use filter (/ip==*/) to trace specific functions.
Function must be listed in /sys/kernel/debug/tracing/available\_filter\_functions
.PP
.RS

.PP
\s+2Note\s-2 of function event
.PP
perf support ftrace:function tracepoint since Linux 3.3 (see below commit),
ktap is based on perf callback, so it means kernel must be newer than 3.3
then can use this feature.

.PP
.RS

.nf
commit ced39002f5ea736b716ae233fb68b26d59783912
Author: Jiri Olsa <jolsa@redhat.com>
Date:   Wed Feb 15 15:51:52 2012 +0100

ftrace, perf: Add support to use function tracepoint in perf 

.fi
.RE

.RE
.IP \n+[step]

\item 
.PP
kprobe:
.PP
EventDef               Description

.ti 0
\l'\n(.lu'

.PP
probe:schedule         trace schedule function
probe:schedule%return  trace schedule function return
probe:SyS\_write        trace SyS\_write function
probe:vfs*             trace wildcards vfs related function

.PP
kprobe functions must be listed in /proc/kallsyms
\item 
.PP
uprobe:
.PP
EventDef                               Description

.ti 0
\l'\n(.lu'

.PP
probe:/lib64/libc.so.6:malloc          trace malloc function
probe:/lib64/libc.so.6:malloc%return   trace malloc function return
probe:/lib64/libc.so.6:free            trace free function
probe:/lib64/libc.so.6:0x82000         trace function with file offset 0x82000
probe:/lib64/libc.so.6:*               trace all libc function

.PP
symbol resolving need libelf support
\item 
.PP
sdt:
.PP
EventDef                               Description

.ti 0
\l'\n(.lu'

.PP
sdt:/libc64/libc.so.6:lll\_futex\_wake   trace stapsdt lll\_futex\_wake
sdt:/libc64/libc.so.6:*                trace all static markers in libc

.PP
sdt resolving need libelf support
.PP
\fBtrace\_end \{ ACTION \}\fP

.SH Tracing Built\-in variables
.PP
\fBarg0..9\fP

.PP
Evaluates to argument 0 to 9 of the event object. If fewer than ten arguments are passed to the current probe, the remaining variables return nil.

.PP
.RS

.PP
\s+2Note\s-2 of arg offset
.PP
The arg offset(0..9) is determined by event format shown in debugfs.

.PP
.RS

.nf
#cat /sys/kernel/debug/tracing/events/sched/sched\_switch/format
name: sched\_switch
ID: 268
format:
    field:char prev\_comm[32];         <\- arg0
    field:pid\_t prev\_pid;             <\- arg1
    field:int prev\_prio;              <\- arg2
    field:long prev\_state;            <\- arg3
    field:char next\_comm[32];         <\- arg4
    field:pid\_t next\_pid;             <\- arg5
    field:int next\_prio;              <\- arg6

.fi
.RE

.PP
As shown above, the tracepoint event \fB\fCsched:sched\_switch\fR takes 7 arguments, from \fB\fCarg0\fR to \fB\fCarg6\fR.

.PP
For syscall event, \fB\fCarg0\fR is the syscall number, not the first argument of the syscall function. Use \fB\fCarg1\fR as the first argument of the syscall function.
For example:

.PP
.RS

.nf
SYSCALL\_DEFINE3(read, unsigned int, fd, char \_\_user *, buf, size\_t, count)
                                    <arg1>             <arg2>       <arg3>

.fi
.RE

.PP
This is similar to kprobe and uprobe, the \fB\fCarg0\fR of kprobe/uprobe events
 is always \fB\fC\_probe\_ip\fR, not the first argument given by the user, for example:

.PP
.RS

.nf
# ktap \-e 'trace probe:/lib64/libc.so.6:malloc size=%di'

# cat /sys/kernel/debug/tracing/events/ktap\_uprobes\_3796/malloc/format
    field:unsigned long \_\_probe\_ip;   <\- arg0
    field:u64 size;                   <\- arg1

.fi
.RE

.RE

.PP
\fBcpu\fP

.PP
returns the current CPU id.

.PP
\fBpid\fP

.PP
returns current process pid.

.PP
\fBtid\fP

.PP
returns the current thread id.

.PP
\fBuid\fP

.PP
returns the current process's uid.

.PP
\fBexecname\fP

.PP
returns the current process executable's name in a string.

.PP
\fBargstr\fP

.PP
Event string representation. You can print it by \fB\fCprint(argstr)\fR, turning the
event into a human readable string. The result is mostly the same as each
entry in \fB\fC/sys/kernel/debug/tracing/trace\fR

.PP
\fBprobename\fP

.PP
Event name. Each event has a name associated with it.
(Dtrace also have 'probename' keyword)

.SH Timer syntax
.PP
\fBtick\-Ns        \{ ACTION \}\fP

.PP
\fBtick\-Nsec      \{ ACTION \}\fP

.PP
\fBtick\-Nms       \{ ACTION \}\fP

.PP
\fBtick\-Nmsec     \{ ACTION \}\fP

.PP
\fBtick\-Nus       \{ ACTION \}\fP

.PP
\fBtick\-Nusec     \{ ACTION \}\fP

.PP
\fBprofile\-Ns     \{ ACTION \}\fP

.PP
\fBprofile\-Nsec   \{ ACTION \}\fP

.PP
\fBprofile\-Nms    \{ ACTION \}\fP

.PP
\fBprofile\-Nmsec  \{ ACTION \}\fP

.PP
\fBprofile\-Nus    \{ ACTION \}\fP

.PP
\fBprofile\-Nusec  \{ ACTION \}\fP

.PP
architecture overview picture reference(pnp format)

.PP
one\-liners

.PP
simple event tracing


.SH Advanced tracing pattern.IP \n+[step]

\item Aggregations/histograms
\item Thread locals
\item Flame graphs

.SH Overhead/Performance.IP \n+[step]

\item ktap has a much shorter startup time than SystemTap (try the helloword script).
\item ktap has a smaller memory footprint than SystemTap
\item Some scripts show that ktap has a little lower overhead than SystemTap
(we chose two scripts to compare, function profile, stack profile.
this is not means all scripts in SystemTap have big overhead than ktap)

.SH FAQ
.PP
\fBQ: Why use a bytecode design?\fP

.PP
A: Using bytecode is a clean and lightweight solution,
   you do not need the GCC toolchain to compile every script; all you
   need is a ktapvm kernel module and the userspace tool called "ktap".
   Since its language uses a virtual machine design, it has a great portability.
   Suppose you are working on a multi\-arch cluster; if you want to run
   a tracing script on each board, you will not need cross\-compile your tracing
   scripts for all the boards. You can just use the \fB\fCktap\fR tool
   to run scripts right away.

.PP
The bytecode\-based design also makes execution safer than the native code
   generation approach.

.PP
It is already observed that SystemTap is not widely used in embedded Linux systems.
   This is mainly caused by the problem of SystemTap's design decisions in its architecture design. It is a natural
   design for Red Hat and IBM, because Red Hat/IBM is focusing on the server area,
   not embedded area.

.PP
\fBQ: What's the differences with SystemTap and DTrace?\fP

.PP
A: For SystemTap, the answer is already mentioned in the above question,
   SystemTap chooses the translator design, sacrificing usability for runtime performance.
   The dependency on the GCC chain when running scripts is the problem that ktap wants to solve.

.PP
DTrace shares the same design decision of using bytecode, so basically
   DTrace and ktap are more alike. There have been some projects aimed at porting
   DTrace from Solaris to Linux, but these efforts are still under way and are relatively slow in progress. DTrace
   has its root in Solaris, and there are many huge differences between Solaris's
   tracing infrastructure and Linux's.

.PP
DTrace is based on D language, a language subset of C. It's a restricted
   language, like without for\-looping, for safe use in production systems.
   It seems that DTrace for Linux only supports x86 architecture, doesn't work on
   PowerPC and ARM/MIPS. Obviously it's not suited for embedded Linux currently.

.PP
DTrace uses ctf as input for debuginfo handing, compared to vmlinux for
   SystemTap.

.PP
On the license part, DTrace is released as CDDL, which is incompatible with
   GPL. (This is why it's impossible to upstream DTrace into mainline.)

.PP
\fBQ: Why use a dynamically\-typed language instead of a statically\-typed language?\fP

.PP
A: It's hard to say which one is better than the other. Dynamically\-typed
   languages bring efficiency and fast prototype production, but lose type
   checking at the compile phase, and it's easy to make mistake in runtime. It also
   needs many runtime checks. In contrast, statically\-typed languages win on
   programming safety and performance. Statically\-typed languages would suit for
   interoperation with the kernel, as the kernel is written mainly in C. Note that
   SystemTap and DTrace both use statically\-typed languages.

.PP
ktap chooses a dynamically\-typed language for its initial implementation.

.PP
\fBQ: Why do we need ktap for event tracing? There is already a built\-in ftrace\fP

.PP
A: This is also a common question for all dynamic tracing tools, not only ktap.
   ktap provides more flexibility than the built\-in tracing infrastructure. Suppose
   you need to print a global variable at a tracepoint hit, or you want to print
   a backtrace. Furthermore, you want to store some info into an associative array, and
   display it as a histogram when tracing ends. \fB\fCftrace\fR cannot handle all these requirements.
   Overall, ktap provides you with great flexibility to script your own trace
   needs.

.PP
\fBQ: How about the performance? Is ktap slow?\fP

.PP
A: ktap is not slow. The bytecode is very high\-level, based on Lua. The language's
   virtual machine is register\-based (compared to the stack\-based JVM and CLR), with a small number of
   instructions. The table data structure is heavily optimized in ktapvm.
   ktap uses per\-cpu allocation in many places, without the global locking scheme.
   It is very fast when executing tracepoint callbacks.
   Performance benchmarks show that the overhead of ktap runtime is nearly
   10% (storing event name into associative array), compared to the full speed
   running time without any tracepoints enabled.

.PP
ktap will keep optimizing unfailingly. Hopefully the overhead will
   decrease to little more than 5%, or even less.

.PP
\fBQ: Why not port a higher\-level language, like Python or Java, directly into the kernel?\fP

.PP
A: I am serious on the size of VM and the memory footprint. The Python VM is too large
   for embedding into the kernel, and Python has many advanced functionalities
   which we do not really need.

.PP
The number of bytecode opcodes of other higher level languages is also big. ktap only has 32
   bytecode opcodes, whereas Python/Java/Erlang all have nearly two hundred opcodes.
   There are also some problems when porting those languages into the kernel.
   Kernel programming is very different from userspace programming,
   like lack of floating\-point numbers, handling sleeping code, deadloop is
   not allowed in the kernel, multi\-thread management, etc. So it is impossible
   to port large language implementations over to the kernel environment with trivial efforts.

.PP
\fBQ: What is the status of ktap now?\fP

.PP
A: Basically it works on x86\-32, x86\-64, PowerPC, ARM. It also could work for
   other hardware architectures, but is not tested yet. (I don't have enough hardware to test.)
   If you find any bugs, fix it with your own programming skills, or just report to me.

.PP
\fBQ: How can I hack on ktap? I want to write some extensions for ktap.\fP

.PP
A: Patches welcome! Volunteers welcome!
   You can write your own libraries to fulfill your specific needs,
   or write scripts for fun.

.PP
\fBQ: What's the plan for ktap? Is there a roadmap?\fP

.PP
A: The current plan is to deliver stable ktapvm kernel modules, more ktap scripts,
   and more bugfixes.


.SH References.IP \n+[step]

\item 
\[la]http://www.brendangregg.com/Slides/SCaLE_Linux_Performance2013.pdf\[ra]
\item 
\[la]http://dtrace.org/blogs/\[ra]
\item 
\[la]http://docs.huihoo.com/opensolaris/dtrace-user-guide/html/index.html\[ra]
\item 
\[la]http://lwn.net/Articles/551314/\[ra]
\item 
\[la]http://lwn.net/Articles/572788/\[ra]
\item 
\[la]https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c63a164271f81220ff4966d41218a9101f3d0ec4\[ra]
\item [ktap introduction in LinuxCon Japan 2013][REFR7(content is out of date)
\item [ktap Examples by Brendan Gregg][REFR8
\item 
\[la]http://www.slideshare.net/brendangregg/what-linux-can-learn-from-solaris-performance-and-viceversa\[ra]
\item 
\[la]http://lwn.net/Articles/595565/\[ra]

.SH History.IP \n+[step]

\item ktap was invented at 2012
\item First RFC sent to LKML at 2012.12.31
\item The code was released in GitHub at 2013.01.18
\item ktap released v0.1 at 2013.05.21
\item ktap released v0.2 at 2013.07.31
\item ktap released v0.3 at 2013.10.29
.PP
For more release info, please look at RELEASES.txt in project root directory.


.SH Examples.IP \(bu 2

\item 
.PP
simplest one\-liner command to enable all tracepoints
.PP
.RS

.nf
ktap \-e "trace *:* \{ print(argstr) \}"

.fi
.RE
\item 
.PP
syscall tracing on target process
.PP
.RS

.nf
ktap \-e "trace syscalls:* \{ print(argstr) \}" \-\- ls

.fi
.RE
\item 
.PP
ftrace(kernel newer than 3.3, and must compiled with CONFIG\_FUNCTION\_TRACER)
.PP
.RS

.nf
ktap \-e "trace ftrace:function \{ print(argstr) \}"


ktap \-e "trace ftrace:function /ip==mutex*/ \{ print(argstr) \}"

.fi
.RE
\item 
.PP
simple syscall tracing
.PP
.RS

.nf
trace syscalls:* \{
        print(cpu, pid, execname, argstr)
\}

.fi
.RE
\item 
.PP
syscall tracing in histogram style
.PP
.RS

.nf
var s = \{\}


trace syscalls:sys\_enter\_* \{
        s[probename] += 1
\}


trace\_end \{
        print\_hist(s)
\}

.fi
.RE
\item 
.PP
kprobe tracing
.PP
.RS

.nf
trace probe:do\_sys\_open dfd=%di fname=%dx flags=%cx mode=+4($stack) \{
        print("entry:", execname, argstr)
\}


trace probe:do\_sys\_open%return fd=$retval \{
        print("exit:", execname, argstr)
\}

.fi
.RE
\item 
.PP
uprobe tracing
.PP
.RS

.nf
trace probe:/lib/libc.so.6:malloc \{
        print("entry:", execname, argstr)
\}


trace probe:/lib/libc.so.6:malloc%return \{
        print("exit:", execname, argstr)
\}

.fi
.RE
\item 
.PP
stapsdt tracing (userspace static marker)
.PP
.RS

.nf
trace sdt:/lib64/libc.so.6:lll\_futex\_wake \{
        print("lll\_futex\_wake", execname, argstr)
\}


or:


#trace all static mark in libc
trace sdt:/lib64/libc.so.6:* \{
        print(execname, argstr)
\}

.fi
.RE
\item 
.PP
timer
.PP
.RS

.nf
tick\-1ms \{
        printf("time fired on one cpu\\n");
\}


profile\-2s \{
        printf("time fired on every cpu\\n");
\}

.fi
.RE
\item 
.PP
FFI (Call kernel function from ktap script, need to compile with FFI=1)
.PP
.RS

.nf
ffi.cdef[[
        int printk(char *fmt, ...);
]]


ffi.C.printk("This message is called from ktap ffi\\n")

.fi
.RE
.PP
More examples can be found at 
\[la]https://github.com/ktap/ktap/tree/master/samples\[ra] directory.


.SH Appendix
.PP
Here is the complete syntax of ktap in extended BNF.
(based on Lua syntax: 
\[la]http://www.lua.org/manual/5.1/manual.html#5.1\[ra])

.PP
.RS

.nf
    chunk ::= \{stat [';']\} [laststat [';']

    block ::= chunk

    stat ::=  varlist '=' explist | 
             functioncall | 
             \{ block \} | 
             while exp \{ block \} | 
             repeat block until exp | 
             if exp \{ block \{elseif exp \{ block \}\} [else block] \} | 
             for Name '=' exp ',' exp [',' exp] \{ block \} | 
             for namelist in explist \{ block \} | 
             function funcname funcbody | 
             function Name funcbody | 
             var namelist ['=' explist] 

    laststat ::= return [explist] | break

    funcname ::= Name \{'.' Name\} [':' Name]

    varlist ::= var \{',' var\}

    var ::=  Name | prefixexp '[' exp ']'| prefixexp '.' Name 

    namelist ::= Name \{',' Name\}

    explist ::= \{exp ',' exp

    exp ::=  nil | false | true | Number | String | '...' | function | 
             prefixexp | tableconstructor | exp binop exp | unop exp 

    prefixexp ::= var | functioncall | '(' exp ')'

    functioncall ::=  prefixexp args | prefixexp ':' Name args 

    args ::=  '(' [explist] ')' | tableconstructor | String 

    function ::= function funcbody

    funcbody ::= '(' [parlist] ')' \{ block \}

    parlist ::= namelist [',' '...'] | '...'

    tableconstructor ::= '\{' [fieldlist] '\}'

    fieldlist ::= field \{fieldsep field\} [fieldsep]

    field ::= '[' exp ']' '=' exp | Name '=' exp | exp

    fieldsep ::= ',' | ';'

    binop ::= '+' | '\-' | '*' | '/' | '^' | '%' | '..' | 
              '<' | '<=' | '>' | '>=' | '==' | '!=' | 
              and | or

    unop ::= '\-'

.fi
.RE

.SH "SEE ALSO"
The full documentation for
.B open
is maintained as a Texinfo manual.  If the
.B info
and
.B open
programs are properly installed at your site, the command
.IP
.B info open
.PP
should give you access to the complete manual.
.TH "The ktap Tutorial"  ""


